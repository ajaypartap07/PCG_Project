# Collected 40 files
# Root: /Users/ajay/Documents/TRU/COMP 4980/Final Project/zep-man
# Generated: 2025-11-25T03:09:59.749458Z

================================================================================
# File: autoloads/scripts/audio_manager.gd

================================================================================
extends Node
#class_name AudioManager


const GAME_READY_STREAM: AudioStream = preload("res://assets/audio/game_ready.wav")
const LEVEL_CLEARED_STREAM: AudioStream = preload("res://assets/audio/success.wav")

@onready var music_player: AudioStreamPlayer = $Music
@onready var pickups_player: AudioStreamPlayer = $Pickups
@onready var enemies_player: AudioStreamPlayer = $Enemies


func _initialize_asserts() -> void:
	var stream_list: Array[AudioStream] = [
		GAME_READY_STREAM
	]
	
	for stream in stream_list:
		assert(stream != null)


func start() -> void:
	self.music_player.set_stream(self.GAME_READY_STREAM)
	self.music_player.play()
	await self.music_player.finished
	Global.game_started.emit()


func on_game_ready() -> void:
	self.start()


func on_level_cleared() -> void:
	self.stop_all_tracks()
	self.music_player.set_stream(LEVEL_CLEARED_STREAM)
	self.music_player.play()


func _initialize_signals() -> void:
	Global.game_ready.connect(on_game_ready)
	Global.level_cleared.connect(on_level_cleared)


enum TrackTypes {
	MUSIC,
	PICKUPS,
	ENEMIES
}

func play_sound_file(sound_file: String, track_type: TrackTypes) -> void:
	match track_type:
		TrackTypes.MUSIC:
			self.music_player.set_stream(load(sound_file))
			self.music_player.play()
		TrackTypes.PICKUPS:
			self.pickups_player.set_stream(load(sound_file))
			self.pickups_player.play()
		TrackTypes.ENEMIES:
			self.enemies_player.set_stream(load(sound_file))
			self.enemies_player.play()
		_:
			printerr("(!) ERROR: In: " + self.get_name() + ": Unandled case in play_sound_file()!")


func stop_track(track_type: TrackTypes) -> void:
	match track_type:
		TrackTypes.MUSIC:
			self.music_player.stop()
		TrackTypes.PICKUPS:
			self.pickups_player.stop()
		TrackTypes.ENEMIES:
			self.enemies_player.stop()
		_:
			printerr("(!) ERROR: In: " + self.get_name() + ": Unandled case in stop_track()!")


func stop_all_tracks() -> void:
	for node in self.get_children():
		node.stop()


func _ready() -> void:
	self._initialize_asserts()
	self._initialize_signals()


================================================================================
# File: autoloads/scripts/global.gd

================================================================================
extends Node
#class_name Global


signal level_cleared
signal game_over
signal new_game_started

signal lives_changed
signal score_changed
signal high_score_changed

signal player_died
signal player_finished_dying
signal game_ready
signal game_started

var initial_lives: int = 2
var lives: int = initial_lives
var max_lives: int = 5
var is_game_over: bool = false
var selected_difficulty: String = "Easy" 


@export var success_sound_file_path: String = "res://assets/audio/success.wav"
## Number of points to score to get an extra life.
var point_to_gain_life_base_cap: int = 4500
var points_to_gain_life_cap: int = point_to_gain_life_base_cap


func reset() -> void:
	is_game_over = false
	set_score(0)
	set_lives(initial_lives)


func set_lives(value: int) -> void:
	lives = value
	self.lives_changed.emit()


func increase_lives(value: int = 1) -> void:
	if lives + value > max_lives: return
	set_lives(lives + value)


func decrease_lives(value: int = 1) -> void:
	var remaining_lives: int = lives - value
	
	if remaining_lives < 0:
		is_game_over = true
		self.game_over.emit()
		return
	
	set_lives(remaining_lives)
	Global.player_died.emit()


var score: int = 0:
	set = set_score
	
func set_score(value: int) -> void:
	score = value
	self.score_changed.emit()
	
	if self.score >= points_to_gain_life_cap:
		self.increase_lives()
		points_to_gain_life_cap += point_to_gain_life_base_cap
		AudioManager.play_sound_file(success_sound_file_path, AudioManager.TrackTypes.MUSIC)
	
	if self.score > self.high_score:
		self.set_high_score(self.score)


func increase_score(value: int) -> void:
	set_score(score + value)


var high_score: int = 0

func set_high_score(value: int) -> void:
	high_score = value
	self.high_score_changed.emit()


const SAVE_GAME_FILE_PATH: String = "user://game_save.res"
var game_save: GameSave = GameSave.new()


var try_to_replace_corrupted_save_file: bool = false

func save_game() -> void:
	game_save.high_score = self.high_score
	var resource_to_save: Error = ResourceSaver.save(game_save, self.SAVE_GAME_FILE_PATH)
	
	if resource_to_save != OK:
		if try_to_replace_corrupted_save_file:
			printerr("(!) ERROR: In: " + self.get_name() + ": Couldn't create a new save game file!")
			return
		printerr("(!) ERROR: In: " + self.get_name() + ": Couldn't save the game save file!")
		
		printerr("Attempting to delete the save game file...")
		var file_removal_error: Error = DirAccess.remove_absolute(SAVE_GAME_FILE_PATH)
		if file_removal_error != OK:
			printerr("(!) ERROR: In: " + self.get_name() + ": Couldn't remove the game save file!")
			return
			
		printerr("Attempting to create a new save game file...")
		try_to_replace_corrupted_save_file = true
		self.save_game()
	

func load_game() -> void:
	var game_save_exists: bool = FileAccess.file_exists(SAVE_GAME_FILE_PATH)
	
	if not game_save_exists:
		save_game()
	
	var game_save_to_load: Object = load(SAVE_GAME_FILE_PATH)
	
	if game_save_to_load == null:
		printerr("(!) ERROR: In: " + self.get_name() + ": Couldn't load the game save file!")
		return
	
	self.set_high_score(game_save_to_load.high_score)


func on_new_game_started() -> void:
	self.reset()


func on_player_died() -> void:
	# Keep progression even if the game didn't end
	self.save_game()


func on_game_over() -> void:
	self.save_game()


func on_level_cleared() -> void:
	self.save_game()


func _ready() -> void:
	assert(FileAccess.file_exists(success_sound_file_path))
	
	self.new_game_started.connect(on_new_game_started)
	self.player_died.connect(on_player_died)
	self.game_over.connect(on_game_over)
	self.level_cleared.connect(on_level_cleared)
	
	self.load_game()
	
	var level_node: Level = get_tree().get_root().get_node_or_null("Level")
	if level_node == null: return
	await level_node.ready
	reset()


================================================================================
# File: autoloads/scripts/scoring_ui.gd

================================================================================
extends Panel
class_name ScoringUI


@onready var score_label: Label = $HBoxContainer/ScoreLabel
@onready var high_score_label: Label = $HBoxContainer/HighScoreLabel


var high_score_label_text: String = ""
var score_label_text: String = ""


func on_score_changed() -> void:
	self.score_label.set_text(tr("Score:\n") + str(Global.score))


func on_high_score_changed() -> void:
	self.high_score_label.set_text(tr("High Score:\n") + str(Global.high_score))


func _ready() -> void:
	Global.score_changed.connect(on_score_changed)
	Global.high_score_changed.connect(on_high_score_changed)
	
	self.high_score_label.set_text(tr("High Score:\n") + str(Global.high_score))
	self.score_label.set_text(tr("Score:\n") + str(Global.score))


================================================================================
# File: autoloads/scripts/settings.gd

================================================================================
extends Node
#class_name Settings


func _ready() -> void:
	TranslationServer.set_locale(OS.get_locale())
	if not OS.is_debug_build():
		DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_FULLSCREEN)


================================================================================
# File: resources/game_save.gd

================================================================================
extends Resource
class_name GameSave

@export var high_score: int = 0


================================================================================
# File: scripts/PCG_Factory/enemy_pcg_factory.gd

================================================================================
extends Node

# This script is responsible for generating enemy parameters procedurally,
# including AI type, speeds, prediction offsets, scatter durations, etc.
# It ensures that each enemy can have unique traits as per game difficulty
# and variability needs.

# Define the possible AI types (those are your subclass scripts)
const AI_TYPES = [
	"EnemyAIAssassin",
	"EnemyAIBourrin",
	"EnemyAIChelou",
    "EnemyAICornichon"
]

# Define difficulty-based parameter bounds for PCG
# These are example values; adjust to fit your balancing
var difficulty_params = {
	"Easy": {
		"speed_min": 1.8,
		"speed_max": 2.0,
		"prediction_min": 2,
		"prediction_max": 3,
		"scatter_min": 4,
		"scatter_max": 6
	},
	"Medium": {
		"speed_min": 2.0,
		"speed_max": 2.4,
		"prediction_min": 3,
		"prediction_max": 5,
		"scatter_min": 3,
		"scatter_max": 5
	},
	"Hard": {
		"speed_min": 10.4,
		"speed_max": 22.8,
		"prediction_min": 15,
		"prediction_max": 26,
		"scatter_min": 12,
		"scatter_max": 24
	}
}

# Main method to generate a random enemy config based on difficulty
func generate_enemy(difficulty: String) -> Dictionary:
	var params = {}
	
	# Pick AI type randomly from list
	params["ai_type"] = AI_TYPES[randi() % AI_TYPES.size()]
	
	# Get the bounds for current difficulty
	var bounds = difficulty_params.get(difficulty, difficulty_params["Medium"]) # default to medium
	
	# Generate speed within bounds
	params["speed"] = randf_range(bounds["speed_min"], bounds["speed_max"])
	
	# Generate prediction offset for AI
	params["prediction_offset"] = randi() % (bounds["prediction_max"] - bounds["prediction_min"]) + bounds["prediction_min"]
	
	# Scatter mode durations
	params["scatter_time"] = randf_range(bounds["scatter_min"], bounds["scatter_max"])

	# Optionally add other parameters like health, aggression levels, special traits
	
	# Return dict with all parameters
	return params

# Call this method from your enemy spawn code to get parameters, then pass to the enemy/AI


================================================================================
# File: scripts/actors/enemy.gd

================================================================================
extends Node2D
class_name Enemy

""" Section added for PCG """
var pcg_speed: float = 0.0 
var pcg_prediction_offset: int = 0
var pcg_scatter_time: float = 0.0
""" Section added for PCG """

var speed: float = 0.0
@export var spawn_point: Marker2D = null
@onready var spawn_position: Vector2 = spawn_point.global_position

@export var initial_direction: Vector2 = Vector2(0.0, 1.0)
var direction: Vector2 = self.initial_direction
var velocity: Vector2 = self.direction

@onready var animation_tree: AnimationTree = $AnimationTree
@onready var anim_node_sm_playback: AnimationNodeStateMachinePlayback = animation_tree.get("parameters/playback")
@onready var colors_animation_player: AnimationPlayer = $ColorsAnimationPlayer

@export var enemy_ai: EnemyAI = null


@export var base_speed: float = 2.35
var chase_speed: float = base_speed
var scatter_speed: float = base_speed
var eaten_speed: float = base_speed * 2
var frightened_speed: float = base_speed / 2.0


@export_group("Sound Files")
@export_file("*.ogg", "*.wav") var frightened_sound_file_path: String = ""
@export_file("*.ogg", "*.wav") var eaten_sound_file_path: String = ""
@export_file("*.ogg", "*.wav") var enemy_going_home_sound_file_path: String = ""
@export_group("")


func enable() -> void:
	set_physics_process(true)


func disable() -> void:
	set_physics_process(false)


func on_game_ready() -> void:
	animation_tree.set("parameters/move/blend_position", Vector2(0.0, 0.0))
	animation_tree.set("parameters/idle/blend_position", self.direction)


func on_game_started() -> void:
	self.enable()


func on_level_cleared() -> void:
	self.disable()


@onready var hurt_box: HurtBox = $HurtBox

func set_hurt_box_disabled(value: bool) -> void:
	for collision_shape in hurt_box.get_children():
		collision_shape.call_deferred("set_disabled", value)


@onready var hit_box: Area2D = $HitBox

func set_hit_box_disabled(value: bool) -> void:
	for collision_shape in hit_box.get_children():
		collision_shape.call_deferred("set_disabled", value)


signal died

func die() -> void:
	self.died.emit()


func on_player_died() -> void:
	self.disable()
	
	animation_tree.set("parameters/idle/blend_position", direction)
	anim_node_sm_playback.travel("idle")


func on_player_finished_dying() -> void:
	if Global.is_game_over: return
	self.set_global_position(spawn_position)
	self.direction = initial_direction
	animation_tree.set("parameters/move/blend_position", self.direction)


func _initialize_signals() -> void:
	Global.game_ready.connect(on_game_ready)
	Global.game_started.connect(on_game_started)
	Global.level_cleared.connect(on_level_cleared)
	Global.player_died.connect(on_player_died)
	Global.player_finished_dying.connect(on_player_finished_dying)


@onready var shared_enemy_ai: SharedEnemyAI = get_tree().get_root().get_node("Level/SharedEnemyAI")
@onready var enemies_timers: EnemiesTimers = shared_enemy_ai.get_node("EnemiesTimers")


func _process(_delta: float) -> void:
	if enemies_timers.frightened_timer.get_time_left() > 0:
		if enemies_timers.frightened_timer.get_time_left() <= 2.0:
			set_process(false)
			colors_animation_player.play("frightened_ending")


var going_home: bool = false


func on_chasing() -> void:
	set_hurt_box_disabled(true)
	set_hit_box_disabled(false)
	speed = chase_speed
	going_home = false
	set_process(false)
	colors_animation_player.play("normal")
	AudioManager.stop_track(AudioManager.TrackTypes.ENEMIES)


func on_scattered() -> void:
	set_hurt_box_disabled(true)
	set_hit_box_disabled(false)
	speed = scatter_speed
	going_home = false
	set_process(false)
	colors_animation_player.play("normal")
	AudioManager.stop_track(AudioManager.TrackTypes.ENEMIES)


func on_eaten() -> void:
	set_hurt_box_disabled(true)
	set_hit_box_disabled(true)
	speed = eaten_speed
	going_home = true
	set_process(false)
	AudioManager.play_sound_file(eaten_sound_file_path, AudioManager.TrackTypes.ENEMIES)
	await AudioManager.enemies_player.finished
	AudioManager.play_sound_file(enemy_going_home_sound_file_path, AudioManager.TrackTypes.ENEMIES)


func on_frightened() -> void:
	set_hurt_box_disabled(false)
	set_hit_box_disabled(true)
	speed = frightened_speed
	going_home = false
	set_process(true)
	colors_animation_player.play("frightened")
	AudioManager.play_sound_file(frightened_sound_file_path, AudioManager.TrackTypes.ENEMIES)


func on_enemy_ai_state_set(state: EnemyAI.States, _enemy: Enemy) -> void:
	match state:
		EnemyAI.States.CHASE:
			on_chasing()
		EnemyAI.States.SCATTER:
			on_scattered()
		EnemyAI.States.EATEN:
			on_eaten()
		EnemyAI.States.FRIGHTENED:
			on_frightened()
		_:
			printerr("(!) ERROR: In: " + self.get_name() + ": Unhandled enemy ai state!")


func _ready() -> void:
	set_process(false)
	assert(spawn_point != null)
	
	assert(FileAccess.file_exists(frightened_sound_file_path))
	assert(FileAccess.file_exists(eaten_sound_file_path))
	assert(FileAccess.file_exists(enemy_going_home_sound_file_path))
	
	enemy_ai.state_set.connect(on_enemy_ai_state_set)
	
	#await enemies_timers.ready
	#enemies_timers.frightened_timer.timeout.connect(on_enemies_timers_frightened_timer_timeout)
	
	self.disable()
	self._initialize_signals()
	self.direction = self.initial_direction
	animation_tree.active = true


var can_move: bool = true

func _physics_process(_delta: float) -> void:
	if can_move:
		velocity = direction * speed
		self.global_position += velocity
		
		if velocity != Vector2(0.0, 0.0):
			if going_home:
				anim_node_sm_playback.travel("going_home")
				colors_animation_player.play("going_home")
			else:
				animation_tree.set("parameters/move/blend_position", direction)
				anim_node_sm_playback.travel("move")
		else:
			animation_tree.set("parameters/idle/blend_position", direction)
			anim_node_sm_playback.travel("idle")

# ============================================
# PCG Initialization
# Called once at level start.
# ============================================
func init_from_pcg(params: Dictionary) -> void:
	# Store raw PCG values for debugging
	pcg_speed = params.get("speed", base_speed)
	pcg_prediction_offset = params.get("prediction_offset", 0)
	pcg_scatter_time = params.get("scatter_time", 4.0)

	# Apply SPEED
	base_speed = pcg_speed
	chase_speed = base_speed
	scatter_speed = base_speed * 0.95   # slightly slower
	eaten_speed = base_speed * 2
	frightened_speed = base_speed * 0.5

	# Apply PREDICTION OFFSET (AI-specific)
	if enemy_ai and enemy_ai.has_method("set_prediction_offset"):
		enemy_ai.set_prediction_offset(pcg_prediction_offset)

	# Apply SCATTER TIME (AI Timers)
	if enemies_timers and enemies_timers.has_method("set_scatter_time"):
		enemies_timers.set_scatter_time(pcg_scatter_time)


================================================================================
# File: scripts/actors/player.gd

================================================================================
extends CharacterBody2D
class_name Player


@export var speed: float = 150.0
@export var spawn_point: Marker2D = null

var spawn_position: Vector2 = Vector2(0.0, 0.0)

var movement_input_vector: Vector2 = Vector2(0.0, 0.0)
var initial_direction: Vector2 = Vector2(1.0, 0.0)
var direction: Vector2 = self.initial_direction
var next_direction: Vector2 = direction


func _unhandled_key_input(_event: InputEvent) -> void:
	movement_input_vector = Vector2(0.0, 0.0)
	
	movement_input_vector.x = Input.get_axis("move_left", "move_right")
	if movement_input_vector.x != 0: return
	
	movement_input_vector.y = Input.get_axis("move_up", "move_down")


@onready var next_direction_detector: Node2D = $NextDirectionRotator/NextDirectionDetector

func can_go_in_next_direction() -> bool:
	for raycast in next_direction_detector.get_children():
		if raycast.is_colliding():
			return false
	return true


@onready var animation_tree: AnimationTree = $AnimationTree
@onready var anim_node_sm_playback: AnimationNodeStateMachinePlayback = animation_tree.get("parameters/playback")


@onready var hurt_box: HurtBox = $HurtBox

func enable() -> void:
	self.set_physics_process(true)
	self.set_process_unhandled_key_input(true)
	hurt_box.enable()


func disable() -> void:
	self.set_physics_process(false)
	self.set_process_unhandled_key_input(false)
	hurt_box.disable()


func die() -> void:
	self.disable()
	Global.decrease_lives()
	anim_node_sm_playback.travel("die")


func _on_animation_tree_animation_finished(anim_name: StringName) -> void:
	if anim_name == "die":
		Global.player_finished_dying.emit()


func on_game_ready() -> void:
	animation_tree.set("parameters/idle/blend_position", next_direction)
	anim_node_sm_playback.travel("idle")


func on_game_started() -> void:
	self.enable()


func on_level_cleared() -> void:
	self.disable()
	animation_tree.set("parameters/idle/blend_position", next_direction)
	anim_node_sm_playback.travel("idle")


func on_finished_dying() -> void:
	if Global.is_game_over: return
	self.set_global_position(self.spawn_position)


func _ready() -> void:
	if spawn_point != null:
		spawn_position = spawn_point.get_global_position()
	
	Global.game_ready.connect(on_game_ready)
	Global.game_started.connect(on_game_started)
	Global.level_cleared.connect(on_level_cleared)
	Global.player_finished_dying.connect(on_finished_dying)
	
	animation_tree.active = true
	self.disable()


@onready var next_direction_rotator: Node2D = $NextDirectionRotator

func _physics_process(_delta: float) -> void:
	if can_go_in_next_direction():
		direction = next_direction
	
	if movement_input_vector != Vector2(0.0, 0.0):
		next_direction = movement_input_vector

		if next_direction.x == -1.0:
			next_direction_rotator.set_rotation(deg_to_rad(180.0))
		elif next_direction.x == 1.0:
			next_direction_rotator.set_rotation(deg_to_rad(0.0))
		elif next_direction.y == -1.0:
			next_direction_rotator.set_rotation(deg_to_rad(-90.0))
		elif next_direction.y == 1.0:
			next_direction_rotator.set_rotation(deg_to_rad(90.0))
	
	if velocity != Vector2(0.0, 0.0):
		animation_tree.set("parameters/move/blend_position", velocity)
		anim_node_sm_playback.travel("move")
	else:
		animation_tree.set("parameters/idle/blend_position", next_direction)
		anim_node_sm_playback.travel("idle")
	
	self.velocity = direction * speed
	self.move_and_slide()


================================================================================
# File: scripts/ai/enemies_timers.gd

================================================================================
extends Node
class_name EnemiesTimers


@onready var pellets: Pellets = get_tree().get_root().get_node("Level/Pickables/Pellets")

@onready var scatter_timer: Timer = $ScatterDurationTimer
@onready var chase_timer: Timer = $ChaseDurationTimer
@onready var frightened_timer: Timer = $FrightenedDurationTimer


func stop_all_timers() -> void:
	for timer in self.get_children():
		timer.stop()


func on_power_pellet_picked_up(_value: int) -> void:
	self.frightened_timer.start()


func on_player_died() -> void:
	self.stop_all_timers()


func on_game_over() -> void:
	self.stop_all_timers()


func _ready() -> void:
	pellets.power_pellet_picked_up.connect(on_power_pellet_picked_up)
	
	Global.player_died.connect(on_player_died)
	Global.game_over.connect(on_game_over)


func _on_scatter_duration_timer_timeout() -> void:
	chase_timer.start()


func _on_chase_duration_timer_timeout() -> void:
	scatter_timer.start()


================================================================================
# File: scripts/ai/enemy-ai/components/bourrin_elroy_mode.gd

================================================================================
extends Node
class_name BourrinElroyMode


@export var enemy_ai: EnemyAIBourrin = null
@onready var enemy: Enemy = enemy_ai.enemy
@onready var enemy_ai_to_wait_enable_ai_timer: Timer = get_tree().get_root().get_node("Level/Actors/Enemies/EnemyCornichon/EnemyAICornichon/EnableAITimer")
@onready var pellets_node: Pellets = get_tree().get_root().get_node("Level/Pickables/Pellets")


var percentage_tier_1: float = 0.08
var percentage_tier_2: float = 0.04

# Assigned on initialization
var remaining_pellets_count: int = 0
var tier_1_pellet_count_treshold: int = 0
var tier_2_pellet_count_treshold: int = 0


func initialize_tiers_and_remaining_pellets() -> void:
	remaining_pellets_count = pellets_node.remaining_pellets_count
	
	tier_1_pellet_count_treshold = round(remaining_pellets_count * percentage_tier_1)
	tier_2_pellet_count_treshold = round(remaining_pellets_count * percentage_tier_2)
	
	if remaining_pellets_count <= 2:
		self.queue_free()
	
	if tier_1_pellet_count_treshold == tier_2_pellet_count_treshold:
		tier_1_pellet_count_treshold = 2
		tier_2_pellet_count_treshold = 1


func on_pellet_picked_up(_value: int) -> void:
	remaining_pellets_count = pellets_node.remaining_pellets_count
	self.check_if_should_enable_elroy_mode()


func on_player_died() -> void:
	disable_elroy_mode()


func on_enemy_to_wait_went_out() -> void:
	self.check_if_should_enable_elroy_mode()


func _ready() -> void:
	assert(enemy_ai != null)
	assert(enemy_ai_to_wait_enable_ai_timer != null)
	
	pellets_node.pellet_picked_up.connect(on_pellet_picked_up)
	Global.player_died.connect(on_player_died)
	enemy_ai_to_wait_enable_ai_timer.timeout.connect(on_enemy_to_wait_went_out)
	
	initialize_tiers_and_remaining_pellets()


func check_if_should_enable_elroy_mode() -> void:
	if remaining_pellets_count <= tier_2_pellet_count_treshold:
		enable_elroy_mode(true)
		return
	elif remaining_pellets_count <= tier_1_pellet_count_treshold:
		enable_elroy_mode(false)
		return


func enable_elroy_mode(go_faster_than_player: bool) -> void:
	enemy_ai.elroy_mode_enabled = true
	
	if not go_faster_than_player:
		enemy_ai.chase_speed = enemy_ai.base_speed * 1.08
	else:
		# ~ as fast as Player
		enemy_ai.chase_speed = enemy_ai.base_speed * 1.2
	
	
	if enemy_ai.current_state == enemy_ai.States.CHASE:
		# REFACTOR: Could reset to chase state again to change the speed
		# but doesn't seem to work:
		#enemy_ai.set_state(enemy_ai.States.CHASE)
		enemy.speed = enemy_ai.chase_speed
	elif enemy_ai.current_state == enemy_ai.States.SCATTER:
		enemy_ai.set_state(enemy_ai.States.CHASE)


@onready var shared_enemy_ai: SharedEnemyAI = get_tree().get_root().get_node("Level/SharedEnemyAI")

func disable_elroy_mode() -> void:
	enemy_ai.elroy_mode_enabled = false
	enemy.chase_speed = enemy.base_speed
	enemy_ai.set_state(shared_enemy_ai.initial_ais_state)


================================================================================
# File: scripts/ai/enemy-ai/components/enable_ai_timer.gd

================================================================================
extends Timer
class_name EnableAITimer


@export var enemy_ai: EnemyAI = null


func on_game_started() -> void:
	self.start()


func on_player_died() -> void:
	self.stop()


func on_game_over() -> void:
	self.stop()


func _ready() -> void:
	assert(enemy_ai != null)
	Global.game_started.connect(on_game_started)
	Global.player_died.connect(on_player_died)
	Global.game_over.connect(on_game_over)


func _on_timeout() -> void:
	enemy_ai.enable()


================================================================================
# File: scripts/ai/enemy-ai/enemy_ai.gd

================================================================================
extends Node2D
class_name EnemyAI


var in_home: bool = true
var prediction_offset := 0
var scatter_duration := 4.0

func set_prediction_offset(value: int) -> void:
	prediction_offset = value

func set_scatter_time(value: float) -> void:
	scatter_duration = value

func on_chasing() -> void:
	set_destination_location(DestinationLocations.CHASE_TARGET)


func on_scattered() -> void:
	set_destination_location(DestinationLocations.SCATTER_AREA)
	go_to_first_scatter_point()


func on_eaten() -> void:
	set_destination_location(DestinationLocations.ENEMIES_HOME)


func on_frightened() -> void:
	set_destination_location(DestinationLocations.RANDOM_LOCATION)
	frightened_timer.start()


enum States {
	CHASE,
	SCATTER,
	EATEN,
	FRIGHTENED
}


var current_state: States = States.SCATTER
var previous_state: States = current_state


signal state_set(value: EnemyAI.States, enemy: Enemy)

func set_state(state: States) -> void:
	if state == current_state and not first_initialization: return
	previous_state = current_state
	current_state = state
	
	match state:
		States.CHASE:
			self.on_chasing()
		States.SCATTER:
			self.on_scattered()
		States.EATEN:
			self.on_eaten()
		States.FRIGHTENED:
			self.on_frightened()
		_:
			printerr("(!) Error in " + self.name + ": Unrecognized state!")

	self.state_set.emit(state, enemy)

# State waiting to be set which updates itself in the background while
# the current one is overrinding it
var background_state: States = self.current_state


@onready var chase_target: Player = get_tree().get_root().get_node("Level/Actors/Players/Player")
@onready var chase_target_position: Vector2 = Vector2(0.0, 0.0)

func __update_chase_target_position() -> void:
	printerr("(!) ERROR in: " + self.name + ": __set_chase_target_position() must be implemented!")


func set_destination_position_to_chase_target_position() -> void:
	__update_chase_target_position()
	set_destination_position(chase_target_position)


@export var scatter_points_node_name: String = ""
@onready var scatter_points_node = get_tree().get_root().get_node("Level/AIWaypoints/" + scatter_points_node_name)
@onready var scatter_point_target_position: Vector2 = Vector2(0.0, 0.0)

@onready var scatter_points: PackedVector2Array = []
var current_scatter_point_index: int = 0

func build_scatter_points_list() -> void:
	for node in scatter_points_node.get_children():
		scatter_points.append(node.global_position)


func go_to_first_scatter_point() -> void:
	current_scatter_point_index = 0
	set_destination_position(scatter_points[current_scatter_point_index])


func go_to_next_scatter_point() -> void:
	set_destination_position(scatter_points[current_scatter_point_index])

	current_scatter_point_index += 1
	if current_scatter_point_index >= scatter_points.size():
		current_scatter_point_index = 0


@onready var enemies: Node = get_tree().get_root().get_node("Level/Actors/Enemies")
@onready var shared_enemy_ai: SharedEnemyAI = get_tree().get_root().get_node("Level/SharedEnemyAI")

func pick_random_destination_position() -> void:
	randomize()
	var random_index: int = randi() % shared_enemy_ai.walkable_tiles_list.size() - 1
	set_destination_position(tile_map_layer.map_to_local(shared_enemy_ai.walkable_tiles_list[random_index]))


@onready var enemies_home: Marker2D = get_tree().get_root().get_node("Level/AIWaypoints/EnemiesHome")
@onready var enemies_home_position: Vector2 = enemies_home.global_position

@export var enemy: Enemy = null

@onready var nav_agent: NavigationAgent2D = $NavigationAgent2D
@onready var tile_map_layer: TileMapLayer = get_tree().get_root().get_node("Level/TileMapLayer")
@onready var tile_size: float = tile_map_layer.get_tile_set().get_tile_size().x

var destination_position: Vector2 = Vector2(0.0, 0.0)

func set_destination_position(value: Vector2) -> void:
	destination_position = value
	nav_agent.set_target_position(destination_position)


enum DestinationLocations {
	CHASE_TARGET,
	SCATTER_AREA,
	ENEMIES_HOME,
	RANDOM_LOCATION
}


# Controls if the destination location is updated on each frame.
# Set to false when the position is set once and not changing later.
var can_update_destination_location: bool = true


var destination_location: DestinationLocations = DestinationLocations.SCATTER_AREA

func set_destination_location(new_destination: DestinationLocations) -> void:
	destination_location = new_destination
	can_update_destination_location = true


func update_destination_location() -> void:
	match destination_location:
		DestinationLocations.CHASE_TARGET:
			set_destination_position_to_chase_target_position()
		DestinationLocations.SCATTER_AREA:
			can_update_destination_location = false
			go_to_next_scatter_point()
		DestinationLocations.ENEMIES_HOME:
			can_update_destination_location = false
			set_destination_position(enemies_home_position)
		DestinationLocations.RANDOM_LOCATION:
			can_update_destination_location = false
			pick_random_destination_position()
		_:
			printerr("(!) ERROR in " + self.name + ": Unrecognized state!")


signal navigation_finished

func on_navigation_finished() -> void:
	match current_state:
		States.EATEN:
			can_update_destination_location = true
			self.set_state(background_state)
		States.FRIGHTENED:
			can_update_destination_location = true
			pick_random_destination_position()
		States.SCATTER:
			can_update_destination_location = false
			go_to_next_scatter_point()
		# Useful for EnemyAICornichon only. AI just stops on player death anyways.
		States.CHASE:
			#can_update_destination_location = true
			set_destination_location(DestinationLocations.CHASE_TARGET)


@onready var pellets: Pellets = get_tree().get_root().get_node("Level/Pickables/Pellets")

func on_power_pellet_picked_up(_value: int) -> void:
	if self.in_home: return
	self.set_state(States.FRIGHTENED)


@onready var shared_ai: SharedEnemyAI = get_tree().get_root().get_node("Level/SharedEnemyAI")
@onready var enemies_timers: EnemiesTimers = shared_ai.get_node("EnemiesTimers")
@onready var scatter_timer: Timer = enemies_timers.get_node("ScatterDurationTimer")
@onready var chase_timer: Timer = enemies_timers.get_node("ChaseDurationTimer")
@onready var frightened_timer: Timer = enemies_timers.get_node("FrightenedDurationTimer")


var cycle_completed_before_permanent_chase_mode: bool = false
var cycle_count_before_permanent_chase_mode: int = 0
var cycle_count_limit_before_permanent_chase_mode: int = 4

func check_if_cycle_completed_before_permanent_chase() -> void:
	if cycle_count_before_permanent_chase_mode >= cycle_count_limit_before_permanent_chase_mode:
		cycle_completed_before_permanent_chase_mode = true


func on_scatter_timer_timeout() -> void:
	background_state = States.CHASE
	if current_state == States.EATEN or current_state == States.FRIGHTENED: return
	
	if not cycle_completed_before_permanent_chase_mode:
		cycle_count_before_permanent_chase_mode += 1
		check_if_cycle_completed_before_permanent_chase()
	
	self.set_state(States.CHASE)


func on_chase_timer_timeout() -> void:
	background_state = States.SCATTER
	if current_state == States.EATEN or current_state == States.FRIGHTENED: return
	
	if not cycle_completed_before_permanent_chase_mode:
		cycle_count_before_permanent_chase_mode += 1
		check_if_cycle_completed_before_permanent_chase()
	else:
		return
		
	self.set_state(States.SCATTER)


func on_frightened_timer_timeout() -> void:
	if current_state == States.EATEN: return
	self.set_state(background_state)


@onready var pathfinding_update_timer: Timer = $PathfindingUpdateTimer

func disable() -> void:
	self.set_physics_process(false)
	pathfinding_update_timer.stop()
	enemy.can_move = false


func enable() -> void:
	self.set_physics_process(true)
	pathfinding_update_timer.start()
	enemy.can_move = true
	self.in_home = false


func on_enemy_died() -> void:
	self.set_state(States.EATEN)


@onready var enable_ai_timer: EnableAITimer = get_node_or_null("EnableAITimer")

func on_game_started() -> void:
	if not enable_ai_timer:
		self.enable()


func on_player_died() -> void:
	self.disable()
	cycle_count_before_permanent_chase_mode = 0
	cycle_completed_before_permanent_chase_mode = false


func on_game_over() -> void:
	self.disable()
	cycle_count_before_permanent_chase_mode = 0
	cycle_completed_before_permanent_chase_mode = false


func on_level_cleared() -> void:
	self.disable()


func _initialize_signals() -> void:
	self.navigation_finished.connect(on_navigation_finished)
	
	scatter_timer.timeout.connect(on_scatter_timer_timeout)
	chase_timer.timeout.connect(on_chase_timer_timeout)
	frightened_timer.timeout.connect(on_frightened_timer_timeout)

	pellets.power_pellet_picked_up.connect(on_power_pellet_picked_up)
	enemy.died.connect(on_enemy_died)
	
	Global.game_started.connect(on_game_started)
	Global.player_died.connect(on_player_died)
	Global.game_over.connect(on_game_over)
	Global.level_cleared.connect(on_level_cleared)


var first_initialization: bool = true

signal initialized
var is_initialized: bool = false

func _initialize():
	build_scatter_points_list()
	is_initialized = true
	self.initialized.emit()


func _ready() -> void:
	assert(enemy != null)
	self.disable()
	self._initialize_signals()
	call_deferred("_initialize")


func _physics_process(_delta: float) -> void:
	enemy.direction = to_local(nav_agent.get_next_path_position()).normalized()


func _on_pathfinding_update_timer_timeout() -> void:
	if can_update_destination_location: update_destination_location()
	
	if nav_agent.is_navigation_finished():
		navigation_finished.emit()
		return


================================================================================
# File: scripts/ai/enemy-ai/enemy_ai_assassin.gd

================================================================================
extends EnemyAI
class_name EnemyAIAssassin


func __update_chase_target_position() -> void:
	chase_target_position = chase_target.global_position + (chase_target.direction * tile_size * 4)

func set_prediction_offset(value: int) -> void:
	prediction_offset = value

func set_scatter_time(value: float) -> void:
	scatter_duration = value


================================================================================
# File: scripts/ai/enemy-ai/enemy_ai_bourrin.gd

================================================================================
extends EnemyAI
class_name EnemyAIBourrin


func __update_chase_target_position() -> void:
	chase_target_position = chase_target.global_position


var elroy_mode_enabled: bool = false

# @override
func on_scattered() -> void:
	if self.elroy_mode_enabled:
		self.set_state(self.States.CHASE)
		return
	
	set_destination_location(DestinationLocations.SCATTER_AREA)
	go_to_first_scatter_point()

func set_prediction_offset(value: int) -> void:
	prediction_offset = value

func set_scatter_time(value: float) -> void:
	scatter_duration = value


================================================================================
# File: scripts/ai/enemy-ai/enemy_ai_chelou.gd

================================================================================
extends EnemyAI
class_name EnemyAIChelou


@onready var enemy_to_target: Enemy = get_tree().get_root().get_node("Level/Actors/Enemies/EnemyBourrin")


func __update_chase_target_position() -> void:
	var cell_away_point_position: Vector2 = chase_target.global_position + (chase_target.direction * tile_size * 2)
	var chase_target_to_enemy_vector: Vector2 = enemy_to_target.global_position - cell_away_point_position
	chase_target_position = cell_away_point_position - chase_target_to_enemy_vector

func set_prediction_offset(value: int) -> void:
	prediction_offset = value

func set_scatter_time(value: float) -> void:
	scatter_duration = value


================================================================================
# File: scripts/ai/enemy-ai/enemy_ai_cornichon.gd

================================================================================
extends EnemyAI
class_name EnemyAICornichon


func __update_chase_target_position() -> void:
	if enemy.global_position.distance_to(chase_target_position) <= tile_size * 8:
		set_destination_location(DestinationLocations.RANDOM_LOCATION)
	else:
		chase_target_position = chase_target.global_position

func set_prediction_offset(value: int) -> void:
	prediction_offset = value

func set_scatter_time(value: float) -> void:
	scatter_duration = value


================================================================================
# File: scripts/bonus_item_activation_timer.gd

================================================================================
extends Timer
class_name BonusItemActivationTimer

## Timer enabling a choosen BonusItem after a random amount of time
## when certain conditions are met.
##
## A list of percentages caps tier is provided.[br]
## Each element of this list represents a percentage of the total pellets amount.[br]
## Each of these percentages then serve to define how much pellets are required
## to enable the timer. This defined amount is a cap.[br]
## At each cap, the timer starts if it wasn't stopped.[br]
## During that time the BonusItem is enabled. Then it's disabled.[br]
## When all caps have been reached, the BonusItem is then queue freed after the 
## BonusItem is disabled for the last time.

@export var bonus_item: BonusItem = null

@export var min_rand_wait_time: int = 9
@export var max_rand_wait_time: int = 10

# PackedFloat32 adds more unecessary numbers after decimals so use 64 instead
## Percentages must be between 0.0 and 1.0 (both of these values aren't included)
var pellet_cap_percentages_tiers: PackedFloat64Array = [0.29, 0.70]

var remaining_activations_count: int = pellet_cap_percentages_tiers.size()
@onready var pellets_node: Pellets = get_tree().get_root().get_node("Level/Pickables/Pellets")

@onready var remaining_pellets_percentage: float = 0.0
@onready var remaining_pellets_cap: int = 0


func on_pellet_picked_up(_value: int) -> void:
	# If current cap not passed, return
	if not pellets_node.remaining_pellets_count <= remaining_pellets_cap:
		return
	# Cap passed from now on
	
	remaining_activations_count -= 1
	
	# If timer not active, start it with random wait_time. Otherwise do nothing.
	if self.is_stopped():
		var active_timer_wait_time: float = float(randi_range(min_rand_wait_time, max_rand_wait_time))
		self.set_wait_time(active_timer_wait_time)
		self.start()
		bonus_item.enable()
	
	pellet_cap_percentages_tiers.remove_at(pellet_cap_percentages_tiers.size() - 1)
	
	# If all caps are passed, stop firing this function
	if pellet_cap_percentages_tiers.size() == 0:
		pellets_node.pellet_picked_up.disconnect(on_pellet_picked_up)
		return
	
	# Change pellets cap
	remaining_pellets_percentage = pellet_cap_percentages_tiers[pellet_cap_percentages_tiers.size() - 1]
	remaining_pellets_cap = int(pellets_node.initial_pellets_count * remaining_pellets_percentage)


func check_if_should_queue_free() -> void:
	if remaining_activations_count <= 0:
		bonus_item.queue_free()


func on_bonus_item_picked_up(_value: int, _texture: Texture2D) -> void:
	self.stop()
	check_if_should_queue_free()


func on_player_died() -> void:
	bonus_item.disable()
	check_if_should_queue_free()
	self.stop()


func on_game_over() -> void:
	bonus_item.queue_free()
	self.stop()


func _initialize_asserts() -> void:
	assert(bonus_item != null)
	assert(min_rand_wait_time < max_rand_wait_time)
	
	# pellet_cap_percentages_tiers checks
	var last_percentage: float = 0.0
	var first_iteration: bool = true
	
	for percentage in pellet_cap_percentages_tiers:
		assert(percentage > 0.0)
		assert(percentage < 1.0)
		
		if first_iteration:
			first_iteration = false
			last_percentage = percentage
			continue
		
		assert(percentage > last_percentage)
		last_percentage = percentage


func _ready() -> void:
	# If no cap to reach is given, queue free
	if pellet_cap_percentages_tiers.size() == 0:
		bonus_item.queue_free()
		return
	
	remaining_pellets_percentage = pellet_cap_percentages_tiers[pellet_cap_percentages_tiers.size() - 1]
	remaining_pellets_cap = int(pellets_node.initial_pellets_count * remaining_pellets_percentage)
	
	self._initialize_asserts()
	
	pellets_node.pellet_picked_up.connect(on_pellet_picked_up)
	bonus_item.picked_up.connect(on_bonus_item_picked_up)
	Global.player_died.connect(on_player_died)
	Global.game_over.connect(on_game_over)
	
	randomize()


func _on_timeout() -> void:
	bonus_item.disable()
	check_if_should_queue_free()


================================================================================
# File: scripts/bonus_items.gd

================================================================================
extends Node
class_name BonusItems


signal item_picked_up(value: int, texture: Texture2D)

const score_value_list: PackedInt32Array = [
	100,
	300,
	500,
	700,
	1000,
	2000,
	3000,
	5000
]

const image_file_path_list: PackedStringArray = [
	"res://resources/atlas-textures/emerald_texture.tres",
	"res://resources/atlas-textures/book_texture.tres",
	"res://resources/atlas-textures/diamond_texture.tres",
	"res://resources/atlas-textures/cookie_texture.tres",
	"res://resources/atlas-textures/cookie_texture.tres",
	"res://resources/atlas-textures/cookie_texture.tres",
	"res://resources/atlas-textures/cookie_texture.tres",
	"res://resources/atlas-textures/cookie_texture.tres"
]

@onready var level: Level = get_tree().get_root().get_node("Level")
## A tier to define each time a new level is loaded
@onready var current_tier: int = 0
var total_tiers_count: int = score_value_list.size()


func on_bonus_item_picked_up(value: int, texture: Texture2D) -> void:
	Global.increase_score(value)
	self.item_picked_up.emit(value, texture)


# Values to inject. Set later.
var score_value: int = 0
var texture_file_path: String = ""


func setup_children() -> void:
	# TODO: Set the current_tier depending on the id of the level
	# and keep track of the collected items between the levels
	# Remove this line when this is done
	current_tier = 1
	
	assert(current_tier > 0 and current_tier <= total_tiers_count)
	
	self.score_value = score_value_list[current_tier - 1]
	self.texture_file_path = image_file_path_list[current_tier - 1]
	
	for bonus_item in self.get_children():
		bonus_item.setup(self.score_value, load(self.texture_file_path))
		bonus_item.picked_up.connect(on_bonus_item_picked_up)


func _initialize_asserts() -> void:
	assert(self.image_file_path_list.size() == self.score_value_list.size())
	
	for image_file in self.image_file_path_list:
		assert(FileAccess.file_exists(image_file))
	
	for value in self.score_value_list:
		assert(value > 0)


func _ready() -> void:
	self._initialize_asserts()
	self.setup_children()


================================================================================
# File: scripts/enemies.gd

================================================================================
extends Node
class_name Enemies


@onready var initial_enemies_count: int = self.get_child_count()


================================================================================
# File: scripts/hurtbox.gd

================================================================================
extends Area2D
class_name HurtBox


@export var actor_to_hurt: Node2D = null


func enable() -> void:
	for collision_shape in self.get_children():
		collision_shape.call_deferred("set_disabled", false)


func disable() -> void:
	for collision_shape in self.get_children():
		collision_shape.call_deferred("set_disabled", true)


func _ready() -> void:
	assert(self.actor_to_hurt != null)


func _on_area_entered(_area: Area2D) -> void:
	self.disable()
	self.actor_to_hurt.die()


================================================================================
# File: scripts/level.gd

================================================================================
extends Node2D
class_name Level


## Defines which level it is.
@export var id: int = 0
@export_file var next_level_to_load_file_path: String = ""

@onready var switch_to_next_level_timer: Timer = $SwitchToNextLevelTimer


func on_player_finished_dying() -> void:
	if Global.is_game_over: return
	Global.game_ready.emit()


func on_level_cleared() -> void:
	switch_to_next_level_timer.start()


func on_game_over() -> void:
	switch_to_next_level_timer.start()


func _ready() -> void:
	assert(self.id > 0)
	
	Global.player_finished_dying.connect(on_player_finished_dying)
	Global.game_ready.emit()
	Global.level_cleared.connect(on_level_cleared)
	Global.game_over.connect(on_game_over)


func _on_switch_to_next_level_timer_timeout() -> void:
	get_tree().change_scene_to_file(next_level_to_load_file_path)


================================================================================
# File: scripts/numbers_displayer.gd

================================================================================
extends Label
class_name NumbersDisplayer


@export_file var file: String = ""

@export var color: Color = Color(1.0, 1.0, 1.0, 1.0)


func _ready() -> void:
	self.set_position(self.get_position() + (-self.get_size() / 2))
	set("theme_override_colors/font_color", self.color)
	
	var tween: Tween = create_tween()
	tween.tween_property(self, "position:y", self.position.y - 10, 0.5).set_trans(Tween.TRANS_LINEAR)
	await tween.finished
	self.queue_free()


================================================================================
# File: scripts/pellets.gd

================================================================================
extends Node
class_name Pellets


var initial_pellets_count: int = 0
var remaining_pellets_count: int = 0

var initial_normal_pellets_count: int = 0
var remaining_normal_pellets_count: int = 0

var initial_power_pellets_count: int = 0
var remaining_power_pellets_count: int = 0


func on_scene_tree_exited_by_pellet() -> void:
	var pellet_types_node_empty_count: int = 0
	
	for pellet_type_node in self.get_children():
		if pellet_type_node.get_child_count() == 0:
			pellet_types_node_empty_count += 1
		
		if pellet_types_node_empty_count == self.get_child_count():
			Global.level_cleared.emit()


func _ready() -> void:
	var current_callable_on_pellet_picked_up: Callable = Callable()
	var callable_on_normal_pellet_picked_up: Callable = on_normal_pellet_picked_up
	var callable_on_power_pellet_picked_up: Callable = on_power_pellet_picked_up
	
	for pellet_type_group in self.get_children():
		if pellet_type_group.get_name() == "Normal":
			current_callable_on_pellet_picked_up = callable_on_normal_pellet_picked_up
			for normal_pellet in pellet_type_group.get_children():
				initial_normal_pellets_count += 1
		elif pellet_type_group.get_name() == "Power":
			current_callable_on_pellet_picked_up = callable_on_power_pellet_picked_up
			for power_pellet in pellet_type_group.get_children():
				initial_power_pellets_count += 1
		else:
			printerr("(!) ERROR! In: " + self.name + ": Unhandled pellet type!")
		
		for pellet in pellet_type_group.get_children():
			pellet.picked_up.connect(on_pellet_picked_up)
			pellet.picked_up.connect(current_callable_on_pellet_picked_up)
			pellet.tree_exited.connect(on_scene_tree_exited_by_pellet)
			
			initial_pellets_count += 1
	
	assert(initial_pellets_count > 0)
	
	remaining_pellets_count = initial_pellets_count
	remaining_normal_pellets_count = initial_normal_pellets_count
	remaining_power_pellets_count = initial_power_pellets_count


signal pellet_picked_up(value: int)
signal normal_pellet_picked_up(value: int)
signal power_pellet_picked_up(value: int)

func on_pellet_picked_up(score_to_add: int) -> void:
	remaining_pellets_count -= 1
	Global.increase_score(score_to_add)
	pellet_picked_up.emit(score_to_add)


func on_normal_pellet_picked_up(score_to_add: int) -> void:
	normal_pellet_picked_up.emit(score_to_add)


func on_power_pellet_picked_up(score_to_add: int) -> void:
	power_pellet_picked_up.emit(score_to_add)


================================================================================
# File: scripts/pickables/bonus_item.gd

================================================================================
extends Pickable
class_name BonusItem


@onready var sprite_2d: Sprite2D = $Sprite2D
@onready var collision_shape_2d: CollisionShape2D = $CollisionShape2D


func enable() -> void:
	self.collision_shape_2d.call_deferred("set_disabled", false)
	self.sprite_2d.show()


func disable() -> void:
	self.collision_shape_2d.call_deferred("set_disabled", true)
	self.sprite_2d.hide()


func setup(new_score_value: int, new_texture: Texture2D) -> void:
	self.score_value = new_score_value
	self.sprite_2d.set_texture(new_texture)


func _ready() -> void:
	assert(numbers_displayer_scene != null)
	self.disable()


@export var numbers_displayer_scene: PackedScene = null

func _on_area_entered(_area: Area2D) -> void:
	self.picked_up.emit(self.score_value, self.sprite_2d.get_texture())
	AudioManager.play_sound_file(sound_file_path, AudioManager.TrackTypes.PICKUPS)
	self.disable()
	
	var numbers_displayer_instance: NumbersDisplayer = numbers_displayer_scene.instantiate()
	numbers_displayer_instance.color = Color(1.0, 1.0, 1.0, 1.0)
	numbers_displayer_instance.set_text(str(self.score_value))
	numbers_displayer_instance.set_global_position(self.get_global_position())
	get_tree().get_root().add_child(numbers_displayer_instance)


================================================================================
# File: scripts/pickables/pickable.gd

================================================================================
extends Area2D
class_name Pickable


@export var score_value: int = 0
@export_file("*.ogg", "*.wav") var sound_file_path: String = ""

signal picked_up(value: int)


func _ready() -> void:
	assert(self.score_value > 0)
	assert(FileAccess.file_exists(sound_file_path))


func _on_area_entered(_area: Area2D) -> void:
	self.picked_up.emit(self.score_value)
	AudioManager.play_sound_file(sound_file_path, AudioManager.TrackTypes.PICKUPS)
	self.queue_free()


================================================================================
# File: scripts/shared_enemy_ai.gd

================================================================================
extends Node
class_name SharedEnemyAI


@onready var tile_map_layer: TileMapLayer = get_tree().get_root().get_node("Level/TileMapLayer")
#@onready var tile_size: float = tile_map_layer.get_tileset().get_tile_size().x


var walkable_tiles_list: PackedVector2Array = []

func build_walkable_tiles_list() -> void:
	for tile in tile_map_layer.get_used_cells():
		var cell_tile_data: TileData = tile_map_layer.get_cell_tile_data(tile)
		if cell_tile_data and cell_tile_data.get_custom_data("walkable"):
			walkable_tiles_list.append(tile)



@onready var enemies_timers: EnemiesTimers = $EnemiesTimers
@onready var scatter_timer: Timer = enemies_timers.get_node("ScatterDurationTimer")
@onready var chase_timer: Timer = enemies_timers.get_node("ChaseDurationTimer")
#@onready var frightened_timer: Timer = enemies_timers.get_node("FrightenedDurationTimer")

@onready var enemies: Enemies = get_tree().get_root().get_node("Level/Actors/Enemies")
var enemy_ai_list: Array[EnemyAI] = []


var frightened_enemy_ais_count: int = 0
var enemies_eaten_combo_count: int = 0

var enemy_base_score_value: int = 200
var enemy_score_value: int = enemy_base_score_value

@export var numbers_displayer_scene: PackedScene = null

func on_enemy_state_set(state: EnemyAI.States, enemy: Enemy) -> void:
	match state:
		EnemyAI.States.EATEN:
			frightened_enemy_ais_count -= 1
			enemies_eaten_combo_count += 1
			if frightened_enemy_ais_count >= 0:
				if enemies_eaten_combo_count > 1:
					enemy_score_value *= 2
				Global.increase_score(enemy_score_value)
				
				var numbers_displayer_instance: NumbersDisplayer = numbers_displayer_scene.instantiate()
				numbers_displayer_instance.color = Color(0.102, 0, 0.945, 1.0)
				numbers_displayer_instance.set_text(str(enemy_score_value))
				numbers_displayer_instance.set_global_position(enemy.get_global_position())
				get_tree().get_root().add_child(numbers_displayer_instance)
				
				total_enemies_eaten_count += 1
				
				if total_enemies_eaten_count >= enemies_to_eat_for_combo_bonus_cap:
					Global.increase_score(combo_bonus_score_value)
		EnemyAI.States.FRIGHTENED:
			frightened_enemy_ais_count += 1


func on_enemies_timers_frightened_timer_timeout() -> void:
	frightened_enemy_ais_count = 0
	enemies_eaten_combo_count = 0
	enemy_score_value = enemy_base_score_value


## This value should stay the same across all EnemyAI s so it's set in this manager scene. 
## Frightened and eaten should not be assigned here as it's not handled cases to
## start with.
@export var initial_ais_state: EnemyAI.States = EnemyAI.States.SCATTER

func on_game_started() -> void:
	var timer_started: bool = false
	
	for enemy_ai: EnemyAI in enemy_ai_list:
		# AI must absolutely be initialized before proceeding
		if not enemy_ai.is_initialized:
			await enemy_ai.initialized
		
		#enemy_ai.state_set.connect(on_enemy_state_set)
		
		enemy_ai.set_state(initial_ais_state)
	
		match initial_ais_state:
			enemy_ai.States.CHASE:
				enemy_ai.background_state = enemy_ai.States.CHASE
				if not timer_started:
					timer_started = true
					chase_timer.start()
			enemy_ai.States.SCATTER:
				enemy_ai.background_state = enemy_ai.States.SCATTER
				if not timer_started:
					timer_started = true
					scatter_timer.start()
			_:
				printerr(("(!) ERROR: In: " + self.get_name() + ": Uhandled state on game started!"))
				
		enemy_ai.first_initialization = false


@onready var pellets: Pellets = get_tree().get_root().get_node("Level/Pickables/Pellets")
@onready var enemies_to_eat_for_combo_bonus_cap = pellets.initial_power_pellets_count * enemies.initial_enemies_count
var total_enemies_eaten_count: int = 0
var combo_bonus_score_value: int = 12000

func _ready() -> void:
	assert(numbers_displayer_scene != null)
	
	Global.game_ready.connect(on_game_started)
	enemies_timers.frightened_timer.timeout.connect(on_enemies_timers_frightened_timer_timeout)
	
	for enemy: Enemy in enemies.get_children():
		enemy_ai_list.append(enemy.enemy_ai)
	
	for enemy_ai in enemy_ai_list:
		self.build_walkable_tiles_list()
		enemy_ai.state_set.connect(on_enemy_state_set)


================================================================================
# File: scripts/ui/bonus_items_ui.gd

================================================================================
extends Panel
class_name BonusItemsUI


@onready var level: Level = get_tree().get_root().get_node("Level")
@onready var bonus_items: BonusItems = level.get_node("Pickables/BonusItems")

@onready var textures_container: HBoxContainer = $MarginContainer/HBoxContainer
var texture_rect_list: Array[TextureRect] = []
@onready var level_label: Label = textures_container.get_node("LevelLabel")


func on_bonus_item_picked_up(_value: int, texture: Texture2D) -> void:
	var texture_rect: TextureRect = self.texture_rect_list[bonus_items.total_tiers_count - 1]
	
	texture_rect.set_texture(texture)
	texture_rect.show()


func _ready() -> void:
	bonus_items.item_picked_up.connect(on_bonus_item_picked_up)
	
	level_label.set_text(str(level.id))
	
	for tier in bonus_items.total_tiers_count:
		var texture_instance: TextureRect = TextureRect.new()
		texture_instance.expand_mode = TextureRect.EXPAND_FIT_WIDTH
		texture_instance.hide()
		
		textures_container.add_child(texture_instance, false, Node.INTERNAL_MODE_FRONT)
		texture_rect_list.append(texture_instance)


================================================================================
# File: scripts/ui/character_info.gd

================================================================================
extends HBoxContainer
class_name CharacterInfo


@export var character_name: String = ""
@onready var label: Label = $Label

var empty_color: Color = Color(0.0, 0.0, 0.0, 0.0)
@export var text_color: Color = empty_color


func _ready() -> void:
	assert(character_name != "")
	label.set_text(tr(self.character_name))
	
	if text_color == empty_color:
		return
	
	self.set_modulate(text_color)


================================================================================
# File: scripts/ui/character_info_list.gd

================================================================================
extends VBoxContainer
class_name CharacterInfoList


@export_category("Debug")
@export var hide_on_ready: bool = true


func _ready() -> void:
	if not hide_on_ready: return
	for node in self.get_children():
		if not node is CharacterInfo: continue
		node.hide()


================================================================================
# File: scripts/ui/difficulty_selection_ui.gd

================================================================================
"""
Author - Ajay Ludher
Difficulty selector screen for Pac-Man style game.
Handles button presses for Easy, Medium, Hard difficulties.
Stores the selected difficulty globally so it can be used for PCG and enemy AI setup.
"""

extends Control
class_name DifficultySelectionUI

# When a button is pressed, save the difficulty and switch to the main menu scene.

func _on_easy_button_pressed() -> void:
	Global.selected_difficulty = "Easy"
	print("Difficulty selected: Easy")
	get_tree().change_scene_to_file("res://scenes/ui/main_menu_ui.tscn")

func _on_medium_button_pressed() -> void:
	Global.selected_difficulty = "Medium"
	print("Difficulty selected: Medium")
	get_tree().change_scene_to_file("res://scenes/ui/main_menu_ui.tscn")

func _on_hard_button_pressed() -> void:
	Global.selected_difficulty = "Hard"
	print("Difficulty selected: Hard")
	get_tree().change_scene_to_file("res://scenes/ui/main_menu_ui.tscn")


================================================================================
# File: scripts/ui/info_message_ui.gd

================================================================================
extends Panel
class_name InfoMessageUI


@onready var label: Label = $MarginContainer/Label

@export var default_color: Color = Color(1.0, 1.0, 1.0, 1.0)
@export var level_cleared_color: Color = Color(0.0, 86.0, 0.360, 1.0)
@export var player_died_color: Color = Color(1.0, 0.55, 0.0, 1.0)
@export var game_over_color: Color = Color(1.0, 0.0, 0.0, 1.0)


func set_text_with_color(txt: String, color: Color = self.default_color) -> void:
	self.label.set_text(txt)
	self.label.add_theme_color_override("font_color", color)
	self.show()


func on_game_ready() -> void:
	self.set_text_with_color(tr("Get ready!"))


func on_game_started() -> void:
	self.hide()


func on_player_died() -> void:
	self.set_text_with_color(tr("You died!"), self.player_died_color)


func on_game_over() -> void:
	self.set_text_with_color(tr("Game over!"), self.game_over_color)


func on_level_cleared() -> void:
	var text: String = tr("Level completed!\nThanks for playing!")
	self.set_text_with_color(text, self.level_cleared_color)


func _initialize_signals() -> void:
	Global.game_ready.connect(on_game_ready)
	Global.game_started.connect(on_game_started)
	Global.player_died.connect(on_player_died)
	Global.game_over.connect(on_game_over)
	Global.level_cleared.connect(on_level_cleared)


func _ready() -> void:
	self.hide()
	self._initialize_signals()


================================================================================
# File: scripts/ui/label_blinking.gd

================================================================================
extends Label
class_name LabelBlinking


var modulation_alpha: float = self.modulate.a
var use_full_opacity: bool = true
@onready var tween: Tween = null


func on_tween_finished() -> void:
	tween = create_tween()
	
	if use_full_opacity:
		modulation_alpha = 1.0
	else:
		modulation_alpha = 0.0
	
	use_full_opacity = not use_full_opacity
	
	tween.finished.connect(on_tween_finished)
	tween.tween_property(self, "modulate:a", modulation_alpha, 1)


func _ready() -> void:
	tween = create_tween()
	tween.finished.connect(on_tween_finished)
	tween.tween_property(self, "modulate:a", 0.0, 1)
	use_full_opacity = true


================================================================================
# File: scripts/ui/lives_ui.gd

================================================================================
extends Panel
class_name LivesUI



@onready var label: Label = $HBoxContainer/Label


func on_lives_changed() -> void:
	self.label.set_text("x " + str(Global.lives))


func _ready() -> void:
	self.label.set_text("x " + str(Global.lives))
	Global.lives_changed.connect(on_lives_changed)


================================================================================
# File: scripts/ui/main_menu_ui.gd

================================================================================
extends Control
class_name MainMenuUI


@export var scene_to_load: PackedScene = null
@export_file("*.ogg", "*.wav") var start_game_sound: String = ""

@onready var character_info_list: VBoxContainer = $CharacterInfoList
@onready var animation_player: AnimationPlayer = $AnimationPlayer

func _ready() -> void:
	assert(scene_to_load != null)
	assert(FileAccess.file_exists(start_game_sound))
	
	self.animation_player.play("intro")


var gui_input_enabled: bool = true

func _gui_input(event: InputEvent) -> void:
	if not gui_input_enabled: return
	if event is InputEventMouseButton:
		gui_input_enabled = false
		accept_event()
		AudioManager.play_sound_file(start_game_sound, AudioManager.TrackTypes.PICKUPS)
		await AudioManager.pickups_player.finished
		Global.new_game_started.emit()
		get_tree().change_scene_to_packed(scene_to_load)


func _unhandled_key_input(event: InputEvent) -> void:
	set_process_unhandled_key_input(false)
	if event is InputEventJoypadButton or event is InputEventKey:
		accept_event()
		if Input.is_action_just_pressed("ui_cancel"):
			get_tree().quit()
		
		AudioManager.play_sound_file(start_game_sound, AudioManager.TrackTypes.PICKUPS)
		await AudioManager.pickups_player.finished
		Global.new_game_started.emit()
		get_tree().change_scene_to_packed(scene_to_load)


================================================================================
# File: scripts/ui/pause_menu_ui.gd

================================================================================
extends Panel
class_name PauseMenuUI


@export var first_element_to_grab_focus: Control = null


func _ready() -> void:
	self.hide()
	assert(first_element_to_grab_focus != null)


func _unhandled_key_input(_event: InputEvent) -> void:
	if Global.is_game_over: return
	
	if Input.is_action_just_pressed("ui_cancel"):
		get_tree().get_root().set_input_as_handled()
		self.set_visible(not self.is_visible())
	
		if self.is_visible():
			get_tree().set_pause(true)
			first_element_to_grab_focus.grab_focus()
		else:
			get_tree().set_pause(false)


func _on_resume_button_pressed() -> void:
	self.set_visible(false)
	get_tree().set_pause(false)


================================================================================
# File: scripts/ui/quit_to_desktop_button.gd

================================================================================
extends Button
class_name QuitToDesktopButton


func _on_pressed() -> void:
	get_tree().quit()


================================================================================
# File: scripts/ui/scene_switcher_button.gd

================================================================================
extends Button
class_name SceneSwitcherButton


@export_file var scene_to_load_file_path: String = ""
@export var scene_to_load_packed_scene: PackedScene = null


func _ready() -> void:
	assert(scene_to_load_file_path != "" or scene_to_load_packed_scene != null)


func _on_pressed() -> void:
	if scene_to_load_file_path != "":
		get_tree().change_scene_to_file(scene_to_load_file_path)
	elif scene_to_load_packed_scene != null:
		get_tree().change_scene_to_packed(scene_to_load_packed_scene)


func _on_tree_exiting() -> void:
	get_tree().set_pause(false)


================================================================================
# File: scripts/ui/score_info.gd

================================================================================
extends HBoxContainer
class_name ScoreInfo


@export var score_value: int = 0
@export var texture_modulation_color: Color = Color(1.0, 1.0, 1.0, 1.0)

@onready var texture_rect: TextureRect = $TextureRect
@onready var label: Label = $Label


func _ready() -> void:
	label.set_text(tr_n("%d point", "%d points", score_value) % score_value)
	texture_rect.set_modulate(texture_modulation_color)


================================================================================
# File: scripts/ui/version_label.gd

================================================================================
extends Label
class_name VersionLabel


func _ready() -> void:
	var version_identifier: String = ProjectSettings.get_setting("application/config/version")
	self.set_text(tr("Version: ") + version_identifier)


================================================================================
# File: scripts/warp_zone.gd

================================================================================
extends Area2D
class_name WarpZone


@export var warp_destination_node: Node2D = null
@onready var warp_destination_position: Vector2 = warp_destination_node.get_global_position()

@onready var collision_shape_2d: CollisionShape2D = $CollisionShape2D


func _ready() -> void:
	# Flush ref, not used anymore
	warp_destination_node = null


func _on_body_entered(body: Player) -> void:
	body.set_global_position(warp_destination_position)

